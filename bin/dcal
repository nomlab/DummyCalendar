#!/usr/bin/env ruby

################################################################
# rbenv support:
# If this file is a symlink, and bound to a specific ruby
# version via rbenv (indicated by RBENV_VERSION),
# I want to resolve the symlink and re-exec
# the original executable respecting the .ruby_version
# which should indicate the right version.
#
if File.symlink?(__FILE__) and ENV["RBENV_VERSION"]
  ENV["RBENV_VERSION"] = nil
  shims_path = File.expand_path("shims", ENV["RBENV_ROOT"])
  ENV["PATH"] = shims_path + ":" + ENV["PATH"]
  exec(File.readlink(__FILE__), *ARGV)
end

gemfile = File.expand_path("../../Gemfile", __FILE__)

if File.exists?(gemfile + ".lock")
  ENV["BUNDLE_GEMFILE"] = gemfile
  require "bundler/setup"
end

require "rubygems"
require "thor"
require File.expand_path("../../lib/dummy_calendar", __FILE__)

class DummyCalendarCLI < Thor
  package_name 'DummyCalendar'
  default_command :help

  DB_PATH = File.expand_path("../../patterns", __FILE__)

  ################################################################
  # command name mappings
  map ["--help", "-h"] => :help
  map ["--generate", "-g"] => :generate


  ################################################################
  # Command: help
  ################################################################
  desc "help [COMMAND]", "Describe available commands or one specific command."
  def help(command = nil)
    super(command)
  end

  ################################################################
  # Command: list
  ################################################################
  desc "list", "Show pattern names list."
  def list
    filenames = pattern_names
    filenames.each do |filename|
      puts filename
    end
  end

  ################################################################
  # Command: generate
  ################################################################
  desc "generate", "Generate dummy events."

  method_option :name, :required => true, :desc => 'pattern name or `all`'
  method_option :range, :required => true, :banner => 'FROM-TO', :desc => 'YYYYMMDD-YYYYMMDD'
  method_option :format, :default => 'csv', :desc => '`csv` or `ics`'

  def generate
    dstart, dend = options[:range].split('-')
    begin
      dstart = Date.parse(dstart)
      dend   = Date.parse(dend)
      raise if dstart >= dend
    rescue
      puts "ERROR: Invalid date"
      exit -1
    end

    @cal = DummyCalendar::Calendar.new
    event_next = {}

    if options[:name] == 'all'
      patterns = pattern_names
      patterns.each do |pattern|
        events = generate_dummy_events(pattern, dstart, dend, pattern)
        @cal.add_events(events)
      end
    elsif options[:name] == 'dbyd'
      patterns = pattern_names
      patterns.each do |pattern|
        events = generate_dummy_events(pattern, dstart, dend, pattern)
        if events[0].timing == 'successively'
          @cal.add_event(events[0])
          @cal.add_event(events[1])
          event_next[pattern] = events[1].dstart.to_date
        else
          @cal.add_events(events)
        end
      end
      now = dstart
      while dend - now != 0
        event_next.each do |key,val|
          if now - val == 0
            events = generate_dummy_events_dbyd(key, now, dend, key)
            if events[1].nil?
              event_next[key] = dend + 1
            else
              @cal.add_event(events[1])
              event_next[key] = events[1].dstart.to_date
            end
          end
        end
        now += 1
      end
    else
      options[:name].split(',').each do |name|
        unless events = generate_dummy_events(name, dstart, dend, name)
          puts "ERROR: Recurrence options[:name] `" + name + "` not found"
          puts "Please select options[:name] in /patterns/*"
          exit -1
        end
        @cal.add_events(events)
      end
    end

    case options[:format]
    when 'csv' then @cal.print_events
    when 'ics' then puts @cal.to_ics
    end
  end

  private

  def generate_dummy_events(name, dstart, dend, recurrence_tag)
    dc = DummyCalendar::EventGenerator.new(recurrence_tag)
    range = dstart..dend
    start_year = dstart.year
    end_year = dend.year

    filenames = Dir.glob("#{DB_PATH}/*").map{|path| path.split('/').last}
    if filenames.include?(name)
      eval File.read "#{DB_PATH}/#{name}"
    else
      return nil
    end

    return dc.generate(dstart, range)
  end

  def generate_dummy_events_dbyd(name, dstart_next, dend, recurrence_tag)
    dc = DummyCalendar::EventGenerator.new(recurrence_tag)
    range = dstart_next..dend
    start_year = dstart_next.year
    end_year = dend.year

    filenames = Dir.glob("#{DB_PATH}/*").map{|path| path.split('/').last}
    if filenames.include?(name)
      eval File.read "#{DB_PATH}/#{name}"
    else
      return nil
    end

    return dc.generate(dstart_next, range)
  end

  def pattern_names
    filenames = Dir.glob("#{DB_PATH}/*").map{|path| path.split('/').last}
  end
end

command = DummyCalendarCLI.start(ARGV)
