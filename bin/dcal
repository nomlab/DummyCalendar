#!/usr/bin/env ruby
# coding: utf-8

################################################################
# rbenv support:
# If this file is a symlink, and bound to a specific ruby
# version via rbenv (indicated by RBENV_VERSION),
# I want to resolve the symlink and re-exec
# the original executable respecting the .ruby_version
# which should indicate the right version.
#
if File.symlink?(__FILE__) and ENV["RBENV_VERSION"]
  ENV["RBENV_VERSION"] = nil
  shims_path = File.expand_path("shims", ENV["RBENV_ROOT"])
  ENV["PATH"] = shims_path + ":" + ENV["PATH"]
  exec(File.readlink(__FILE__), *ARGV)
end

gemfile = File.expand_path("../../Gemfile", __FILE__)

if File.exists?(gemfile + ".lock")
  ENV["BUNDLE_GEMFILE"] = gemfile
  require "bundler/setup"
end

require "rubygems"
require "thor"
require "json"
require File.expand_path("../../lib/dummy_calendar", __FILE__)

class DummyCalendarCLI < Thor
  package_name 'DummyCalendar'
  default_command :help

  DB_PATH = File.expand_path("../../generated/patterns", __FILE__)

  ################################################################
  # command name mappings
  map ["--help", "-h"] => :help
  map ["--generate", "-g"] => :generate


  ################################################################
  # Command: help
  ################################################################
  desc "help [COMMAND]", "Describe available commands or one specific command."
  def help(command = nil)
    super(command)
  end

  ################################################################
  # Command: list
  ################################################################
  desc "list", "Show pattern names list."
  def list
    filenames = pattern_names
    filenames.each do |filename|
      puts filename
    end
  end

  ################################################################
  # Command: generate
  ################################################################
  desc "generate", "Generate dummy events."

  method_option :name, :required => true, :desc => 'pattern name or `all`'
  method_option :range, :required => true, :banner => 'FROM-TO', :desc => 'YYYYMMDD-YYYYMMDD'
  method_option :format, :default => 'csv', :desc => '`csv` or `ics`'
  method_option :max_time, :default => 360

  def generate
    dstart, dend = options[:range].split('-')
    begin
      dstart = Date.parse(dstart)
      dend   = Date.parse(dend)
      raise if dstart >= dend
    rescue
      puts "ERROR: Invalid date"
      exit -1
    end

    @cal = DummyCalendar::Calendar.new
    event_next = {}
    max_time = options[:max_time].to_i
    orig_range = dstart..dend
    dstart -= 365

    if options[:name] == 'all'
      patterns = pattern_names
      patterns.each do |pattern|
        events = generate_dummy_events(pattern, dstart, dend, pattern, max_time)
        @cal.add_events(events, orig_range)
      end
    elsif options[:name] == 'group'
      $used_time = {}
      @cal = load_cal_list
      @cal.each do |name, hash|
        hash["cal"] = DummyCalendar::Calendar.new
        hash["user"].each do |name, val|
          $used_time[name] = {} if $used_time[name] == nil
        end
        hash["cal"].add_non_reccrence(max_time, orig_range, name, hash["user"])
      end
      patterns = pattern_names
      patterns.each do |pattern|
        events = generate_dummy_events(pattern, dstart, dend, pattern, max_time, @cal)
        if events[0].timing == 'successively'
          @cal["#{events[0].categories}"]["cal"].add_event(events[0], orig_range, @cal["#{events[0].categories}"]["user"])
          @cal["#{events[0].categories}"]["cal"].add_event(events[1], orig_range, @cal["#{events[0].categories}"]["user"])
          event_next[pattern] = events[1].dstart.to_date
        else
          @cal["#{events[0].categories}"]["cal"].add_events(events, orig_range, @cal["#{events[0].categories}"]["user"])
        end
      end
      now = dstart
      while dend - now != 0
        event_next.each do |key,val|
          if now - val == 0
            events = generate_dummy_events_dbyd(key, now, dend, key, max_time, @cal)
            if events[1].nil?
              event_next[key] = dend + 1
            else
              @cal["#{events[0].categories}"]["cal"].add_event(events[1], orig_range, @cal["#{events[0].categories}"]["user"])
              event_next[key] = events[1].dstart.to_date
            end
          end
        end
        now += 1
      end
    else
      options[:name].split(',').each do |name|
        unless events = generate_dummy_events(name, dstart, dend, name)
          puts "ERROR: Recurrence options[:name] `" + name + "` not found"
          puts "Please select options[:name] in /patterns/*"
          exit -1
        end
        @cal.add_events(events)
      end
    end

    case options[:format]
    when 'csv' then @cal.print_events
    when 'ics' then
      if options[:name] == 'group'
        @cal.each do |name, hash|
          puts name
          puts hash["cal"].to_ics
        end
      else
        puts @cal.to_ics
      end
    end
  end

  private

  def generate_dummy_events(name, dstart, dend, recurrence_tag, max_time, cals)
    dc = DummyCalendar::EventGenerator.new(recurrence_tag)
    range = dstart..dend
    start_year = dstart.year
    end_year = dend.year

    filenames = Dir.glob("#{DB_PATH}/recurrence/*").map{|path| path.split('/').last}
    if filenames.include?(name)
      eval File.read "#{DB_PATH}/recurrence/#{name}"
    else
      return nil
    end

    return dc.generate(dstart, range, max_time, cals)
  end

  # eval File.readでdstart_nextを書き換えてしまうため，別名をつけたメソッドを用意した
  def generate_dummy_events_dbyd(name, dstart_next, dend, recurrence_tag, max_time, cals)
    dc = DummyCalendar::EventGenerator.new(recurrence_tag)
    range = dstart_next..dend
    start_year = dstart_next.year
    end_year = dend.year

    filenames = Dir.glob("#{DB_PATH}/recurrence/*").map{|path| path.split('/').last}
    if filenames.include?(name)
      eval File.read "#{DB_PATH}/recurrence/#{name}"
    else
      return nil
    end

    return dc.generate(dstart_next, range, max_time, cals)
  end

  def pattern_names
    filenames = Dir.glob("#{DB_PATH}/recurrence/*").map{|path| path.split('/').last}
  end

  def load_cal_list
    begin
      json = File.read "#{DB_PATH}/cal_list"
    rescue
      puts "Please run pattern_gen first."
      exit(1)
    end
    cal_list = JSON.parse(json)
    return cal_list
  end
end

command = DummyCalendarCLI.start(ARGV)
